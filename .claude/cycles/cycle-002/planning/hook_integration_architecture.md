# Hook Integration Architecture - Cycle 2
**Project**: Context Extender CLI Tool
**Phase**: Planning Phase
**Date**: 2025-09-16
**Component**: Hook-to-Database Integration

## üéØ **Architecture Overview**

### **Integration Flow**
```
Claude Code Event ‚Üí Hook Trigger ‚Üí Database Handler ‚Üí SQLite Database
                                 ‚Üì
                          Event Processing
                                 ‚Üì
                          Transaction Management
                                 ‚Üì
                          Performance Monitoring
```

### **Key Architecture Changes**
1. **Remove**: All JSONL file creation logic from Cycle 1
2. **Replace**: File writes with direct database inserts
3. **Maintain**: Hook registration and configuration system
4. **Enhance**: Error handling and recovery mechanisms

## üìê **Component Architecture**

### **1. Database Connection Manager**
```go
package database

import (
    "database/sql"
    "sync"
    "time"

    _ "github.com/mattn/go-sqlite3"
)

type DBManager struct {
    db        *sql.DB
    mu        sync.RWMutex
    queries   *Queries      // Generated by sqlc
    stats     *Statistics
    config    *DBConfig
}

type DBConfig struct {
    Path           string
    Encrypted      bool
    Key            []byte
    MaxOpenConns   int
    MaxIdleConns   int
    ConnMaxLifetime time.Duration
}

func NewDBManager(config *DBConfig) (*DBManager, error) {
    var db *sql.DB
    var err error

    if config.Encrypted {
        db, err = openEncryptedDB(config.Path, config.Key)
    } else {
        db, err = sql.Open("sqlite3", config.Path+"?_journal=WAL")
    }

    if err != nil {
        return nil, fmt.Errorf("failed to open database: %w", err)
    }

    // Configure connection pool
    db.SetMaxOpenConns(config.MaxOpenConns)
    db.SetMaxIdleConns(config.MaxIdleConns)
    db.SetConnMaxLifetime(config.ConnMaxLifetime)

    // Apply performance pragmas
    if err := applyPragmas(db); err != nil {
        return nil, fmt.Errorf("failed to configure database: %w", err)
    }

    return &DBManager{
        db:      db,
        queries: New(db), // sqlc generated
        stats:   NewStatistics(),
        config:  config,
    }, nil
}

func applyPragmas(db *sql.DB) error {
    pragmas := []string{
        "PRAGMA foreign_keys = ON",
        "PRAGMA journal_mode = WAL",
        "PRAGMA synchronous = NORMAL",
        "PRAGMA temp_store = MEMORY",
        "PRAGMA mmap_size = 30000000000",
        "PRAGMA cache_size = 10000",
        "PRAGMA busy_timeout = 10000",
    }

    for _, pragma := range pragmas {
        if _, err := db.Exec(pragma); err != nil {
            return err
        }
    }
    return nil
}
```

### **2. Hook Database Handler**
```go
package hooks

import (
    "context"
    "encoding/json"
    "time"

    "github.com/google/uuid"
    "github.com/yourusername/context-extender/internal/database"
)

type DatabaseHookHandler struct {
    dbManager     *database.DBManager
    sessionStore  *SessionStore
    eventBuffer   *EventBuffer
    metricsCollector *MetricsCollector
}

type SessionStore struct {
    activeSessions map[string]*SessionState
    mu            sync.RWMutex
}

type SessionState struct {
    ID            string
    WorkingDir    string
    StartTime     time.Time
    EventCount    int
    LastEventSeq  int
}

func NewDatabaseHookHandler(dbManager *database.DBManager) *DatabaseHookHandler {
    return &DatabaseHookHandler{
        dbManager:     dbManager,
        sessionStore:  NewSessionStore(),
        eventBuffer:   NewEventBuffer(100), // Buffer for batch inserts
        metricsCollector: NewMetricsCollector(),
    }
}
```

### **3. Hook Event Handlers**

#### **SessionStart Handler**
```go
func (h *DatabaseHookHandler) HandleSessionStart(data json.RawMessage) error {
    start := time.Now()
    defer h.metricsCollector.RecordHookExecution("session_start", time.Since(start))

    var event SessionStartEvent
    if err := json.Unmarshal(data, &event); err != nil {
        return fmt.Errorf("failed to parse session start event: %w", err)
    }

    // Generate or extract session ID
    sessionID := event.SessionID
    if sessionID == "" {
        sessionID = uuid.New().String()
    }

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // Create database transaction
    tx, err := h.dbManager.BeginTx(ctx)
    if err != nil {
        return fmt.Errorf("failed to start transaction: %w", err)
    }
    defer tx.Rollback()

    // Insert session record
    err = h.dbManager.queries.CreateSession(ctx, database.CreateSessionParams{
        ID:          sessionID,
        StartTime:   time.Now(),
        WorkingDir:  event.WorkingDirectory,
        ProjectName: extractProjectName(event.WorkingDirectory),
        Status:      "active",
        Source:      "hook",
    })

    if err != nil {
        return fmt.Errorf("failed to create session: %w", err)
    }

    // Insert session_start event
    err = h.dbManager.queries.AddEvent(ctx, database.AddEventParams{
        SessionID:      sessionID,
        EventType:      "session_start",
        Timestamp:      time.Now(),
        SequenceNumber: 1,
        Data:          string(data),
    })

    if err != nil {
        return fmt.Errorf("failed to add session start event: %w", err)
    }

    // Commit transaction
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit transaction: %w", err)
    }

    // Update session store
    h.sessionStore.AddSession(sessionID, &SessionState{
        ID:           sessionID,
        WorkingDir:   event.WorkingDirectory,
        StartTime:    time.Now(),
        EventCount:   1,
        LastEventSeq: 1,
    })

    return nil
}
```

#### **UserPrompt Handler**
```go
func (h *DatabaseHookHandler) HandleUserPrompt(data json.RawMessage) error {
    start := time.Now()
    defer h.metricsCollector.RecordHookExecution("user_prompt", time.Since(start))

    var event UserPromptEvent
    if err := json.Unmarshal(data, &event); err != nil {
        return fmt.Errorf("failed to parse user prompt event: %w", err)
    }

    // Get active session for working directory
    session := h.sessionStore.GetActiveSession(event.WorkingDirectory)
    if session == nil {
        // Create new session if none exists
        sessionID := uuid.New().String()
        if err := h.createNewSession(sessionID, event.WorkingDirectory); err != nil {
            return err
        }
        session = h.sessionStore.GetActiveSession(event.WorkingDirectory)
    }

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // Increment sequence number
    session.LastEventSeq++

    // Add event to database
    err := h.dbManager.queries.AddEvent(ctx, database.AddEventParams{
        SessionID:      session.ID,
        EventType:      "user_prompt",
        Timestamp:      time.Now(),
        SequenceNumber: session.LastEventSeq,
        Data:          string(data),
    })

    if err != nil {
        return fmt.Errorf("failed to add user prompt event: %w", err)
    }

    // Update session event count
    session.EventCount++
    err = h.dbManager.queries.UpdateSessionEventCount(ctx, database.UpdateSessionEventCountParams{
        ID:         session.ID,
        EventCount: session.EventCount,
    })

    if err != nil {
        return fmt.Errorf("failed to update event count: %w", err)
    }

    return nil
}
```

#### **ClaudeResponse Handler**
```go
func (h *DatabaseHookHandler) HandleClaudeResponse(data json.RawMessage) error {
    start := time.Now()
    defer h.metricsCollector.RecordHookExecution("claude_response", time.Since(start))

    var event ClaudeResponseEvent
    if err := json.Unmarshal(data, &event); err != nil {
        return fmt.Errorf("failed to parse Claude response event: %w", err)
    }

    session := h.sessionStore.GetActiveSession(event.WorkingDirectory)
    if session == nil {
        return fmt.Errorf("no active session for directory: %s", event.WorkingDirectory)
    }

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    session.LastEventSeq++

    // Check if response includes tool usage
    var toolName *string
    if event.ToolUsed != "" {
        toolName = &event.ToolUsed
    }

    err := h.dbManager.queries.AddEvent(ctx, database.AddEventParams{
        SessionID:      session.ID,
        EventType:      "claude_response",
        Timestamp:      time.Now(),
        SequenceNumber: session.LastEventSeq,
        Data:          string(data),
        ToolName:      toolName,
    })

    if err != nil {
        return fmt.Errorf("failed to add Claude response event: %w", err)
    }

    session.EventCount++

    return nil
}
```

#### **SessionEnd Handler**
```go
func (h *DatabaseHookHandler) HandleSessionEnd(data json.RawMessage) error {
    start := time.Now()
    defer h.metricsCollector.RecordHookExecution("session_end", time.Since(start))

    var event SessionEndEvent
    if err := json.Unmarshal(data, &event); err != nil {
        return fmt.Errorf("failed to parse session end event: %w", err)
    }

    session := h.sessionStore.GetActiveSession(event.WorkingDirectory)
    if session == nil {
        return fmt.Errorf("no active session to end for directory: %s", event.WorkingDirectory)
    }

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // Begin transaction for session completion
    tx, err := h.dbManager.BeginTx(ctx)
    if err != nil {
        return fmt.Errorf("failed to start transaction: %w", err)
    }
    defer tx.Rollback()

    // Add session end event
    session.LastEventSeq++
    err = h.dbManager.queries.AddEvent(ctx, database.AddEventParams{
        SessionID:      session.ID,
        EventType:      "session_end",
        Timestamp:      time.Now(),
        SequenceNumber: session.LastEventSeq,
        Data:          string(data),
    })

    if err != nil {
        return fmt.Errorf("failed to add session end event: %w", err)
    }

    // Update session status and end time
    err = h.dbManager.queries.CompleteSession(ctx, database.CompleteSessionParams{
        ID:         session.ID,
        EndTime:    sql.NullTime{Time: time.Now(), Valid: true},
        Status:     "completed",
        EventCount: session.EventCount + 1,
    })

    if err != nil {
        return fmt.Errorf("failed to complete session: %w", err)
    }

    // Process conversation data (generate summary, extract topics, etc.)
    go h.processCompletedSession(session.ID)

    // Commit transaction
    if err := tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit transaction: %w", err)
    }

    // Remove from active sessions
    h.sessionStore.RemoveSession(session.ID)

    return nil
}
```

### **4. Error Handling and Recovery**
```go
type ErrorHandler struct {
    maxRetries     int
    retryDelay     time.Duration
    fallbackWriter *FallbackWriter
}

type FallbackWriter struct {
    mu       sync.Mutex
    basePath string
}

func (fw *FallbackWriter) WriteFallback(eventType string, data []byte) error {
    fw.mu.Lock()
    defer fw.mu.Unlock()

    // Write to fallback file if database is unavailable
    filename := fmt.Sprintf("%s/fallback_%s_%d.json",
        fw.basePath, eventType, time.Now().Unix())

    return os.WriteFile(filename, data, 0644)
}

func (h *DatabaseHookHandler) HandleEventWithRetry(eventType string, handler func() error, data []byte) error {
    var lastErr error

    for attempt := 0; attempt <= h.errorHandler.maxRetries; attempt++ {
        if err := handler(); err != nil {
            lastErr = err

            // Check if error is retryable
            if !isRetryableError(err) {
                break
            }

            if attempt < h.errorHandler.maxRetries {
                time.Sleep(h.errorHandler.retryDelay * time.Duration(attempt+1))
                continue
            }
        } else {
            // Success
            return nil
        }
    }

    // All retries failed, use fallback
    if err := h.errorHandler.fallbackWriter.WriteFallback(eventType, data); err != nil {
        return fmt.Errorf("database and fallback both failed: %w", lastErr)
    }

    // Schedule recovery task to import fallback data later
    h.scheduleRecovery()

    return nil
}

func isRetryableError(err error) bool {
    // Check for retryable database errors
    if strings.Contains(err.Error(), "SQLITE_BUSY") ||
       strings.Contains(err.Error(), "SQLITE_LOCKED") ||
       strings.Contains(err.Error(), "database is locked") {
        return true
    }
    return false
}
```

### **5. Performance Optimization**

#### **Batch Insert Buffer**
```go
type EventBuffer struct {
    events    []database.AddEventParams
    mu        sync.Mutex
    maxSize   int
    flushChan chan struct{}
}

func (eb *EventBuffer) Add(event database.AddEventParams) {
    eb.mu.Lock()
    defer eb.mu.Unlock()

    eb.events = append(eb.events, event)

    if len(eb.events) >= eb.maxSize {
        select {
        case eb.flushChan <- struct{}{}:
        default:
            // Channel already has flush signal
        }
    }
}

func (eb *EventBuffer) FlushWorker(dbManager *database.DBManager) {
    ticker := time.NewTicker(5 * time.Second) // Flush every 5 seconds
    defer ticker.Stop()

    for {
        select {
        case <-eb.flushChan:
            eb.flush(dbManager)
        case <-ticker.C:
            eb.flush(dbManager)
        }
    }
}

func (eb *EventBuffer) flush(dbManager *database.DBManager) error {
    eb.mu.Lock()
    if len(eb.events) == 0 {
        eb.mu.Unlock()
        return nil
    }

    events := make([]database.AddEventParams, len(eb.events))
    copy(events, eb.events)
    eb.events = eb.events[:0]
    eb.mu.Unlock()

    // Batch insert
    ctx := context.Background()
    tx, err := dbManager.BeginTx(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    for _, event := range events {
        if err := dbManager.queries.AddEvent(ctx, event); err != nil {
            return err
        }
    }

    return tx.Commit()
}
```

#### **Connection Pooling**
```go
// Optimal connection pool settings for SQLite
const (
    MaxOpenConns    = 1    // SQLite only supports one writer
    MaxIdleConns    = 1    // Keep connection warm
    ConnMaxLifetime = 0    // Don't expire connections
)

// For read operations, use separate read-only connection pool
type ReadPool struct {
    connections []*sql.DB
    index       int
    mu          sync.Mutex
}

func NewReadPool(dbPath string, size int) (*ReadPool, error) {
    pool := &ReadPool{
        connections: make([]*sql.DB, size),
    }

    for i := 0; i < size; i++ {
        db, err := sql.Open("sqlite3", dbPath+"?mode=ro")
        if err != nil {
            return nil, err
        }
        pool.connections[i] = db
    }

    return pool, nil
}

func (rp *ReadPool) GetConnection() *sql.DB {
    rp.mu.Lock()
    defer rp.mu.Unlock()

    conn := rp.connections[rp.index]
    rp.index = (rp.index + 1) % len(rp.connections)
    return conn
}
```

### **6. Metrics and Monitoring**
```go
type MetricsCollector struct {
    hookExecutionTimes map[string]*RollingAverage
    eventCounts        map[string]int64
    errorCounts        map[string]int64
    mu                sync.RWMutex
}

func (mc *MetricsCollector) RecordHookExecution(hookType string, duration time.Duration) {
    mc.mu.Lock()
    defer mc.mu.Unlock()

    if avg, exists := mc.hookExecutionTimes[hookType]; exists {
        avg.Add(duration.Milliseconds())
    } else {
        avg := NewRollingAverage(100)
        avg.Add(duration.Milliseconds())
        mc.hookExecutionTimes[hookType] = avg
    }

    mc.eventCounts[hookType]++
}

func (mc *MetricsCollector) GetStats() map[string]interface{} {
    mc.mu.RLock()
    defer mc.mu.RUnlock()

    stats := make(map[string]interface{})

    for hookType, avg := range mc.hookExecutionTimes {
        stats[hookType+"_avg_ms"] = avg.Average()
        stats[hookType+"_count"] = mc.eventCounts[hookType]
        stats[hookType+"_errors"] = mc.errorCounts[hookType]
    }

    return stats
}
```

## üîå **Hook Configuration Updates**

### **Updated settings.json Structure**
```json
{
  "hooks": {
    "SessionStart": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "C:\\Users\\marko\\IdeaProjects\\context-extender\\context-extender.exe db-capture --event=session-start",
            "timeout": 5
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "C:\\Users\\marko\\IdeaProjects\\context-extender\\context-extender.exe db-capture --event=user-prompt",
            "timeout": 5
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "C:\\Users\\marko\\IdeaProjects\\context-extender\\context-extender.exe db-capture --event=claude-response",
            "timeout": 5
          }
        ]
      }
    ],
    "SessionEnd": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "C:\\Users\\marko\\IdeaProjects\\context-extender\\context-extender.exe db-capture --event=session-end",
            "timeout": 5
          }
        ]
      }
    ]
  }
}
```

### **CLI Command Updates**
```go
// New db-capture command replacing old capture command
var dbCaptureCmd = &cobra.Command{
    Use:   "db-capture",
    Short: "Capture conversation events directly to database",
    RunE: func(cmd *cobra.Command, args []string) error {
        eventType, _ := cmd.Flags().GetString("event")

        // Read event data from stdin
        data, err := io.ReadAll(os.Stdin)
        if err != nil {
            return fmt.Errorf("failed to read event data: %w", err)
        }

        // Get database handler
        handler := GetDatabaseHandler()

        // Route to appropriate handler
        switch eventType {
        case "session-start":
            return handler.HandleSessionStart(data)
        case "user-prompt":
            return handler.HandleUserPrompt(data)
        case "claude-response":
            return handler.HandleClaudeResponse(data)
        case "session-end":
            return handler.HandleSessionEnd(data)
        default:
            return fmt.Errorf("unknown event type: %s", eventType)
        }
    },
}
```

## üìä **Performance Requirements**

### **Hook Execution Targets**
```
Maximum execution time per hook: 5ms
Database write latency: <2ms
Event buffering: 100 events max
Batch flush interval: 5 seconds
Fallback activation: After 3 retries
Recovery check interval: 1 minute
```

### **Database Performance Targets**
```
Session creation: <2ms
Event insertion: <1ms (buffered)
Batch insert: 1000 events/second
Transaction commit: <5ms
Query response: <10ms
```

## ‚úÖ **Implementation Checklist**

- [ ] Remove all JSONL file creation code
- [ ] Implement database connection manager
- [ ] Create hook database handlers
- [ ] Implement event buffering system
- [ ] Add error handling and fallback
- [ ] Create performance monitoring
- [ ] Update hook configuration
- [ ] Test transaction handling
- [ ] Verify performance targets
- [ ] Add recovery mechanisms

---

**Status**: ‚úÖ **ARCHITECTURE COMPLETE**
**Next**: Implementation roadmap creation